import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, CreateDateColumn, JoinColumn, Index } from 'typeorm';
import { Inventory } from './Inventory';

export enum InventoryLogType {
  STOCK_IN = 'stock_in',
  STOCK_OUT = 'stock_out',
  ADJUSTMENT = 'adjustment',
  TRANSFER = 'transfer',
  WASTE = 'waste',
  EXPIRED = 'expired',
  DAMAGED = 'damaged',
  RETURN = 'return',
  INITIAL_STOCK = 'initial_stock',
  RECOUNT = 'recount'
}

export enum InventoryLogReason {
  PURCHASE = 'purchase',
  SALE = 'sale',
  PRODUCTION = 'production',
  TRANSFER_IN = 'transfer_in',
  TRANSFER_OUT = 'transfer_out',
  WASTE_DISPOSAL = 'waste_disposal',
  EXPIRY = 'expiry',
  DAMAGE = 'damage',
  CUSTOMER_RETURN = 'customer_return',
  SUPPLIER_RETURN = 'supplier_return',
  INVENTORY_COUNT = 'inventory_count',
  SYSTEM_ADJUSTMENT = 'system_adjustment',
  MANUAL_ADJUSTMENT = 'manual_adjustment',
  THEFT = 'theft',
  PROMOTION = 'promotion',
  SAMPLING = 'sampling',
  QUALITY_CONTROL = 'quality_control'
}

@Entity('inventory_logs')
@Index(['inventoryId', 'createdAt'])
@Index(['logType', 'createdAt'])
@Index(['reason'])
@Index(['orderId'])
@Index(['userId'])
export class InventoryLog {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column({ type: 'uuid' })
  @Index()
  inventoryId!: string;

  @ManyToOne(() => Inventory, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'inventoryId' })
  inventory!: Inventory;

  @Column({
    type: 'varchar', length: 50,
    
    default: InventoryLogType.ADJUSTMENT
  })
  @Index()
  logType!: InventoryLogType;

  @Column({
    type: 'varchar', length: 50,
    
    default: InventoryLogReason.MANUAL_ADJUSTMENT
  })
  reason!: InventoryLogReason;

  @Column({ type: 'decimal', precision: 10, scale: 3 })
  quantityChange!: number; // Can be positive or negative

  @Column({ type: 'decimal', precision: 10, scale: 3 })
  quantityBefore!: number;

  @Column({ type: 'decimal', precision: 10, scale: 3 })
  quantityAfter!: number;

  @Column({ type: 'decimal', precision: 12, scale: 2, nullable: true })
  unitCost?: number; // Cost per unit at time of transaction

  @Column({ type: 'decimal', precision: 12, scale: 2, nullable: true })
  totalCost?: number; // Total cost of the transaction

  @Column({ type: 'varchar', length: 255, nullable: true })
  batchNumber?: string; // Batch or lot number

  @Column({ type: 'date', nullable: true })
  expiryDate?: Date; // For items with expiry dates

  @Column({ type: 'varchar', length: 255, nullable: true })
  supplier?: string; // Supplier for stock in

  @Column({ type: 'varchar', length: 255, nullable: true })
  location?: string; // Storage location

  @Column({ type: 'uuid', nullable: true })
  orderId?: string; // Related order ID

  @Column({ type: 'varchar', length: 255, nullable: true })
  orderNumber?: string; // Related order number

  @Column({ type: 'uuid', nullable: true })
  userId?: string; // User who made the change

  @Column({ type: 'varchar', length: 255, nullable: true })
  userName?: string; // Snapshot of user name

  @Column({ type: 'varchar', length: 255, nullable: true })
  documentNumber?: string; // Purchase order, invoice, etc.

  @Column({ type: 'text', nullable: true })
  notes?: string; // Additional notes

  @Column({ type: 'text', nullable: true })
  metadata?: string; // JSON object for additional data

  @Column({ type: 'varchar', length: 45, nullable: true })
  ipAddress?: string; // IP address of the user

  @Column({ type: 'varchar', length: 255, nullable: true })
  deviceInfo?: string; // Device information

  @Column({ type: 'boolean', default: false })
  isSystemGenerated!: boolean; // Was this log auto-generated by system

  @Column({ type: 'boolean', default: false })
  isReversal!: boolean; // Is this a reversal transaction

  @Column({ type: 'uuid', nullable: true })
  reversalOfLogId?: string; // ID of the original log being reversed

  @Column({ type: 'uuid', nullable: true })
  reversedByLogId?: string; // ID of the log that reversed this one

  @CreateDateColumn()
  createdAt!: Date;

  // Computed properties
  get typeDisplayName(): string {
    const typeMap = {
      [InventoryLogType.STOCK_IN]: 'Masuk',
      [InventoryLogType.STOCK_OUT]: 'Keluar',
      [InventoryLogType.ADJUSTMENT]: 'Penyesuaian',
      [InventoryLogType.TRANSFER]: 'Transfer',
      [InventoryLogType.WASTE]: 'Limbah',
      [InventoryLogType.EXPIRED]: 'Kadaluarsa',
      [InventoryLogType.DAMAGED]: 'Rusak',
      [InventoryLogType.RETURN]: 'Retur',
      [InventoryLogType.INITIAL_STOCK]: 'Stok Awal',
      [InventoryLogType.RECOUNT]: 'Recount'
    };
    return typeMap[this.logType] || this.logType;
  }

  get reasonDisplayName(): string {
    const reasonMap = {
      [InventoryLogReason.PURCHASE]: 'Pembelian',
      [InventoryLogReason.SALE]: 'Penjualan',
      [InventoryLogReason.PRODUCTION]: 'Produksi',
      [InventoryLogReason.TRANSFER_IN]: 'Transfer Masuk',
      [InventoryLogReason.TRANSFER_OUT]: 'Transfer Keluar',
      [InventoryLogReason.WASTE_DISPOSAL]: 'Pembuangan Limbah',
      [InventoryLogReason.EXPIRY]: 'Kadaluarsa',
      [InventoryLogReason.DAMAGE]: 'Kerusakan',
      [InventoryLogReason.CUSTOMER_RETURN]: 'Retur Pelanggan',
      [InventoryLogReason.SUPPLIER_RETURN]: 'Retur Supplier',
      [InventoryLogReason.INVENTORY_COUNT]: 'Perhitungan Stok',
      [InventoryLogReason.SYSTEM_ADJUSTMENT]: 'Penyesuaian Sistem',
      [InventoryLogReason.MANUAL_ADJUSTMENT]: 'Penyesuaian Manual',
      [InventoryLogReason.THEFT]: 'Kehilangan',
      [InventoryLogReason.PROMOTION]: 'Promosi',
      [InventoryLogReason.SAMPLING]: 'Sampling',
      [InventoryLogReason.QUALITY_CONTROL]: 'Quality Control'
    };
    return reasonMap[this.reason] || this.reason;
  }

  get isIncrease(): boolean {
    return this.quantityChange > 0;
  }

  get isDecrease(): boolean {
    return this.quantityChange < 0;
  }

  get absoluteQuantityChange(): number {
    return Math.abs(this.quantityChange);
  }

  get impactPercentage(): number {
    if (this.quantityBefore === 0) return 0;
    return (Math.abs(this.quantityChange) / this.quantityBefore) * 100;
  }

  get isSignificantChange(): boolean {
    return this.impactPercentage > 10; // More than 10% change
  }

  // Helper methods
  getParsedMetadata(): any {
    try {
      return this.metadata ? JSON.parse(this.metadata) : {};
    } catch {
      return {};
    }
  }

  setParsedMetadata(data: any): void {
    this.metadata = JSON.stringify(data);
  }

  // Business logic methods
  calculateTotalCost(): void {
    if (this.unitCost) {
      this.totalCost = Math.abs(this.quantityChange) * this.unitCost;
    }
  }

  // Static factory methods
  static createStockInLog(
    inventoryId: string,
    quantity: number,
    quantityBefore: number,
    reason: InventoryLogReason,
    userId?: string,
    orderId?: string,
    options: {
      unitCost?: number;
      supplier?: string;
      batchNumber?: string;
      expiryDate?: Date;
      location?: string;
      documentNumber?: string;
      notes?: string;
    } = {}
  ): Partial<InventoryLog> {
    const log: Partial<InventoryLog> = {
      inventoryId,
      logType: InventoryLogType.STOCK_IN,
      reason,
      quantityChange: quantity,
      quantityBefore,
      quantityAfter: quantityBefore + quantity,
      userId,
      orderId,
      ...options
    };

    if (options.unitCost) {
      log.unitCost = options.unitCost;
      log.totalCost = quantity * options.unitCost;
    }

    return log;
  }

  static createStockOutLog(
    inventoryId: string,
    quantity: number,
    quantityBefore: number,
    reason: InventoryLogReason,
    userId?: string,
    orderId?: string,
    options: {
      unitCost?: number;
      batchNumber?: string;
      location?: string;
      orderNumber?: string;
      notes?: string;
    } = {}
  ): Partial<InventoryLog> {
    const log: Partial<InventoryLog> = {
      inventoryId,
      logType: InventoryLogType.STOCK_OUT,
      reason,
      quantityChange: -quantity,
      quantityBefore,
      quantityAfter: quantityBefore - quantity,
      userId,
      orderId,
      ...options
    };

    if (options.unitCost) {
      log.unitCost = options.unitCost;
      log.totalCost = quantity * options.unitCost;
    }

    return log;
  }

  static createAdjustmentLog(
    inventoryId: string,
    quantityChange: number,
    quantityBefore: number,
    reason: InventoryLogReason,
    userId: string,
    notes?: string
  ): Partial<InventoryLog> {
    return {
      inventoryId,
      logType: InventoryLogType.ADJUSTMENT,
      reason,
      quantityChange,
      quantityBefore,
      quantityAfter: quantityBefore + quantityChange,
      userId,
      notes,
      isSystemGenerated: false
    };
  }

  static createWasteLog(
    inventoryId: string,
    quantity: number,
    quantityBefore: number,
    reason: InventoryLogReason,
    userId: string,
    notes?: string
  ): Partial<InventoryLog> {
    return {
      inventoryId,
      logType: InventoryLogType.WASTE,
      reason,
      quantityChange: -quantity,
      quantityBefore,
      quantityAfter: quantityBefore - quantity,
      userId,
      notes
    };
  }

  static createExpiredLog(
    inventoryId: string,
    quantity: number,
    quantityBefore: number,
    expiryDate: Date,
    batchNumber?: string
  ): Partial<InventoryLog> {
    return {
      inventoryId,
      logType: InventoryLogType.EXPIRED,
      reason: InventoryLogReason.EXPIRY,
      quantityChange: -quantity,
      quantityBefore,
      quantityAfter: quantityBefore - quantity,
      expiryDate,
      batchNumber,
      isSystemGenerated: true,
      notes: `Item expired on ${expiryDate.toDateString()}`
    };
  }

  static createTransferLog(
    inventoryId: string,
    quantity: number,
    quantityBefore: number,
    fromLocation: string,
    toLocation: string,
    userId: string,
    documentNumber?: string
  ): Partial<InventoryLog> {
    return {
      inventoryId,
      logType: InventoryLogType.TRANSFER,
      reason: InventoryLogReason.TRANSFER_OUT,
      quantityChange: -quantity,
      quantityBefore,
      quantityAfter: quantityBefore - quantity,
      location: fromLocation,
      userId,
      documentNumber,
      notes: `Transferred to ${toLocation}`
    };
  }

  static createReversalLog(
    originalLog: InventoryLog,
    userId: string,
    reason?: string
  ): Partial<InventoryLog> {
    return {
      inventoryId: originalLog.inventoryId,
      logType: originalLog.logType,
      reason: InventoryLogReason.SYSTEM_ADJUSTMENT,
      quantityChange: -originalLog.quantityChange,
      quantityBefore: originalLog.quantityAfter,
      quantityAfter: originalLog.quantityBefore,
      userId,
      isReversal: true,
      reversalOfLogId: originalLog.id,
      notes: `Reversal of transaction: ${reason || 'Manual reversal'}`
    };
  }

  // Validation
  validate(): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (this.quantityChange === 0) {
      errors.push('Perubahan quantity tidak boleh nol');
    }

    if (this.quantityBefore < 0) {
      errors.push('Quantity sebelumnya tidak boleh negatif');
    }

    if (this.quantityAfter < 0) {
      errors.push('Quantity setelahnya tidak boleh negatif');
    }

    if (Math.abs(this.quantityAfter - (this.quantityBefore + this.quantityChange)) > 0.001) {
      errors.push('Perhitungan quantity tidak konsisten');
    }

    if (this.unitCost && this.unitCost < 0) {
      errors.push('Unit cost tidak boleh negatif');
    }

    if (this.totalCost && this.totalCost < 0) {
      errors.push('Total cost tidak boleh negatif');
    }

    if (this.expiryDate && this.expiryDate <= new Date()) {
      errors.push('Tanggal kadaluarsa harus di masa depan');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // Mark as reversed
  markAsReversed(reversalLogId: string): void {
    this.reversedByLogId = reversalLogId;
  }

  // Check if this log can be reversed
  canBeReversed(): boolean {
    return !this.isReversal && !this.reversedByLogId;
  }

  // Get summary for reporting
  getSummary(): {
    type: string;
    reason: string;
    change: string;
    date: string;
    user?: string;
    cost?: string;
  } {
    return {
      type: this.typeDisplayName,
      reason: this.reasonDisplayName,
      change: `${this.quantityChange > 0 ? '+' : ''}${this.quantityChange}`,
      date: this.createdAt.toLocaleDateString('id-ID'),
      user: this.userName,
      cost: this.totalCost ? `Rp ${this.totalCost.toLocaleString('id-ID')}` : undefined
    };
  }
}
